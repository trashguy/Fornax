# Phase 2003 — srv/wm (Window Manager)

## Status: Planned

## Goal
Core of the windowing system. Multiplexes draw/input per window using namespaces.

## Decisions (open)

- **Namespace binding**: The key idea is "window = namespace." When srv/wm
  creates a window, it needs to bind window-local /dev/draw and /dev/kbd into
  the client's namespace. This requires `SYS.bind` (currently unimplemented) or
  the supervisor doing it on behalf. Who does the binding — srv/wm via syscall,
  or the kernel/supervisor as part of window creation?
- **Compositing strategy**: (a) srv/wm composites into a single offscreen buffer,
  then flushes to srv/draw → srv/gpu. (b) Each window draws directly to its
  region of the framebuffer (no compositing, no overlapping). Option (a) supports
  overlapping windows and transparency. Option (b) is simpler (tiling only).
  Start with (b) tiling, add (a) later?
- **Window decorations**: Who draws title bars, borders, close buttons? (a) srv/wm
  draws them (server-side decorations, like X11 window managers). (b) Each app
  draws its own (client-side decorations, like Wayland). Server-side is simpler
  and consistent.
- **Focus model**: Click-to-focus or focus-follows-mouse? Does the focused window
  get all keyboard input, or can multiple windows read /dev/kbd? Click-to-focus
  is simpler and less surprising.
- **Window creation flow**: Client opens /dev/wm/ctl and sends "new w h title" —
  but how does it then get access to its window-local /dev/draw? Does srv/wm
  respond with an fd? Or does it bind into the client's namespace and the client
  re-opens /dev/draw? The latter is more Plan 9 but requires namespace
  manipulation from srv/wm.
- **Tiling vs floating**: Start with simple tiling (split screen)? Or jump to
  floating windows with z-ordering? Tiling avoids compositing complexity entirely.

## How It Works
1. Client requests new window via /dev/wm/ctl
2. srv/wm allocates a draw context on srv/draw, clipped to window rect
3. Creates window-specific devices bound into client's namespace:
   - `/dev/draw` → clipped drawing context
   - `/dev/mouse` → coordinates relative to window
   - `/dev/kbd` → focused window gets keys
   - `/dev/cons` → window's text I/O
4. Composites all windows → sends to srv/draw → srv/gpu

## Provides
- `/dev/wm/ctl` — create/destroy/resize/move windows
- `/dev/wm/event` — focus, minimize, close events

## IPC Protocol
```
T_CTL  "new w h title"        → R_OK + window_id
T_CTL  "destroy id"           → R_OK
T_CTL  "resize id w h"        → R_OK
T_CTL  "move id x y"          → R_OK
T_CTL  "focus id"             → R_OK
T_CTL  "raise id"             → R_OK
T_CTL  "title id string"      → R_OK
T_CTL  "list"                 → R_OK + window list
T_READ (event)                → R_OK + WmEvent (focus/unfocus/close/resize)
T_CLOSE                       → R_OK
```

## Window State
```
struct Window {
    id: u32,
    x: i32, y: i32,
    width: u32, height: u32,
    title: [64]u8,
    draw_ctx: u32,      // srv/draw context id
    owner_pid: u32,
    focused: bool,
    visible: bool,
    z_order: u16,
}
```

## Key Insight
A window is just a namespace. No protocol, no display server API. Processes read/write files.

## Compositing
- srv/wm maintains z-ordered window list
- On damage: re-blit affected windows to srv/draw screen context
- Decorations (title bar, borders) drawn by srv/wm itself

## Dependencies
- Phase 2001: srv/draw
- Phase 2002: srv/input
- Kernel: SYS.bind or equivalent namespace manipulation from userspace
