# Phase 2000 — srv/gpu (Modesetting + Framebuffer)

## Status: Planned

## Goal
Userspace GPU driver server. Owns hardware exclusively. All other servers access display through it.

## Decisions (open)

- **Framebuffer access mechanism**: New `SYS.fbmap` syscall that maps the GOP
  framebuffer into the calling process's address space? Or a more general
  `SYS.mmap` that can map any physical range? fbmap is simpler and
  purpose-built; mmap is reusable but more complex to get right.
- **Shared framebuffer vs IPC pixel transfer**: Should srv/draw get direct
  mapped access to the framebuffer (fast, needs shared memory), or go through
  IPC writes to srv/gpu (slower, cleaner isolation)? Shared memory needs a
  mechanism for srv/gpu to grant access to another process.
- **Console handoff**: The kernel console currently writes directly to the
  framebuffer. When srv/gpu takes over, should the console be disabled? Should
  srv/gpu inherit the console text? Or should they coexist (kernel console as
  fallback if srv/gpu crashes)?
- **Single mount point vs multiple**: Mount as one server at `/dev/gpu` with
  subpaths (info, fb, ctl) differentiated by T_OPEN argument? Or three separate
  channels/mount points? Current IPC only supports one channel per mount point,
  so subpath routing via T_OPEN data seems right.
- **Pixel format negotiation**: Always 32bpp BGRA/RGBA (whatever GOP gives us)?
  Or should srv/gpu abstract the format and always present a canonical format to
  clients, converting internally?

## Provides
- `/dev/gpu/ctl` — modesetting (resolution, refresh rate)
- `/dev/gpu/fb` — raw framebuffer (read/write pixel data)
- `/dev/gpu/info` — GPU model, VRAM size, supported modes, current resolution

## IPC Protocol
```
T_OPEN "info"   → R_OK (opens info subdevice)
T_OPEN "fb"     → R_OK (opens framebuffer subdevice)
T_OPEN "ctl"    → R_OK (opens control subdevice)
T_READ  (info)  → R_OK + FbInfo struct (width, height, stride, bpp, format)
T_READ  (fb)    → R_OK + pixel data chunk (offset-based)
T_WRITE (fb)    → R_OK (write pixels at offset)
T_CTL   "mode WxH" → R_OK (set resolution — stretch goal)
T_CLOSE         → R_OK
```

## Implementation
1. Kernel adds framebuffer access syscall — maps UEFI GOP framebuffer into calling process
2. srv/gpu calls the syscall at startup to get framebuffer base + info
3. Serves /dev/gpu/* via IPC message loop on fd 3
4. Uses UEFI GOP as initial backend (framebuffer address from boot info)

## Backend: UEFI GOP
- Framebuffer physical address from `BootInfo.framebuffer`
- Pixel format: BGR or RGB (32bpp, 8 bits per channel)
- No modesetting initially — use mode set by firmware

## Stretch Goal
- AMD Display Core (DCN) modesetting
- PCI BAR mapping for direct GPU register access

## Key Design
srv/gpu owns the hardware exclusively. All other servers go through it.

## Dependencies
- Phase 17: spawn syscall (done)
- Kernel: framebuffer mapping syscall (new)
