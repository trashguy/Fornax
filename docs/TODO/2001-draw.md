# Phase 2001 — srv/draw (2D Drawing Server)

## Status: Planned

## Goal
Plan 9-style draw device. Translates drawing commands to framebuffer writes.

## Decisions (open)

- **Faithful Plan 9 /dev/draw or simplified?**: Plan 9 devdraw has a complex
  binary protocol (draw(3)). Should we replicate it for compatibility with
  plan9port programs? Or design a simpler text-based CTL protocol that's easier
  to implement and debug? Text is slower but much easier to get right first.
- **Drawing context memory**: Each context (image) needs a pixel buffer. Where
  does that memory come from? Kernel heap via brk? A new `SYS.mmap` for
  anonymous pages? Fixed-size pool in srv/draw's BSS? Pool is simplest for MVP.
- **Font rendering**: Should srv/draw handle text rendering (needs a font), or
  should clients rasterize text themselves and blit pixels? Built-in font
  (reuse kernel's font8x16.bin) is simpler. Client-side gives more flexibility.
- **Damage tracking**: Should srv/draw track dirty rectangles and only flush
  changed regions to srv/gpu? Or always flush the entire context? Dirty tracking
  is an optimization — skip for MVP?
- **Access to srv/gpu**: Does srv/draw get direct framebuffer access (mapped
  memory from srv/gpu), or does it write pixels via IPC to srv/gpu? Direct
  access is much faster for full-screen updates.

## Provides
- `/dev/draw/new` — allocate a drawing context (image)
- `/dev/draw/ctl` — drawing commands (rect, line, text, blit)
- `/dev/draw/data` — pixel data read/write
- `/dev/draw/refresh` — damage notification

## IPC Protocol
```
T_OPEN "new"      → R_OK + context_id
T_OPEN "ctl"      → R_OK (control channel for drawing commands)
T_OPEN "data"     → R_OK (pixel data channel)
T_CTL  "alloc id w h" → R_OK (allocate offscreen image)
T_CTL  "rect id x y w h color" → R_OK (fill rectangle)
T_CTL  "line id x1 y1 x2 y2 color" → R_OK (draw line)
T_CTL  "text id x y color string" → R_OK (draw text)
T_CTL  "blit dst_id dx dy src_id sx sy w h" → R_OK (copy pixels)
T_CTL  "flush id" → R_OK (push image to screen via srv/gpu)
T_CTL  "free id"  → R_OK (free offscreen image)
T_WRITE (data)    → R_OK (bulk pixel upload to current context)
T_READ  (data)    → R_OK + pixel data
T_CLOSE           → R_OK
```

## Implementation
1. Opens /dev/gpu/fb at startup to get framebuffer access
2. Maintains pool of drawing contexts (images), each with pixel buffer
3. Drawing commands operate on context pixels
4. Flush copies context pixels to framebuffer via srv/gpu

## Reference
Plan 9 `/dev/draw` interface, devdraw from plan9port.

## Dependencies
- Phase 2000: srv/gpu (framebuffer access)
